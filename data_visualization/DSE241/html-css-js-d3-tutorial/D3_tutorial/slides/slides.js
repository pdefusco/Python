// Generated by CoffeeScript 1.12.2
(function() {
  var circles3, empty_svg, init_svg, rect1, rect3, shapes, title;

  empty_svg = function() {
    return d3.select('div.output').append('svg').attr("width", 500).attr("height", 666);
  };

  shapes = function() {
    var svg;
    svg = d3.select('div.output').append('svg').attr("width", 400).attr("height", 300);
    svg.append("circle").attr("class", "myCircles").attr("id", "circle_top").attr("cx", 40).attr("cy", 60).attr("r", 30);
    svg.append("circle").attr("class", "myCircles").attr("id", "circle_bottom").attr("cx", 40).attr("cy", 120).attr("r", 20);
    svg.append("rect").attr("x", 100).attr("y", 60).attr("width", 30).attr("height", 50).style("fill", "orange");
    return svg.append("line").attr("x2", 250).attr("y2", 90).attr("x1", 150).attr("y1", 60).attr("stroke", "black").attr("stroke-width", 2);
  };

  circles3 = function() {
    var svg;
    svg = d3.select('div.output').append('svg').attr("width", 400).attr("height", 300);
    svg.append("circle").attr("cx", 40).attr("cy", 60).attr("r", 10);
    svg.append("circle").attr("cx", 140).attr("cy", 60).attr("r", 10);
    return svg.append("circle").attr("cx", 240).attr("cy", 60).attr("r", 10);
  };

  rect1 = function() {
    var svg;
    svg = d3.select('div.output').append('svg');
    return svg.append("rect").attr("x", 150).attr("y", 100).attr("width", 60).attr("height", 300);
  };

  rect3 = function() {
    var svg;
    svg = d3.select('div.output').append('svg');
    svg.append("rect").attr("x", 200).attr("y", 300).attr("width", 40).attr("height", 50);
    svg.append("rect").attr("x", 100).attr("y", 20).attr("width", 30).attr("height", 50);
    return svg.append("rect").attr("x", 10).attr("y", 200).attr("width", 25).attr("height", 90);
  };

  slide.title("A basic understanding of JavaScript will save you a lot of pain when you go to build something");

  slide.code("JavaScript Basics", null, "// Single line comments can be written like this\n\n/* \n  And multi-line comments like this\n*/\n\n// To print output we use console.log()\nconsole.log(\"Hello World!\");\n\n// Whitespace (including newlines) is ignored so..\nconsole.log(\"Single line\");\n\n// is the same as\nconsole\n    .log(\n             \"Not a single line\"     );\n\n// Statements are ended with semi-colons\nconsole.log(\"So we can\"); console.log(\"do this\");");

  slide.code("JavaScript Variables: Numbers", null, "// Javascript variables are defined with 'var'\n// and are dynamically typed (like python)\n\n// Their names must start with a alphabetic \n// character and can consist of integers\n// and underscores\n\n// There is only one number type (float64)\nvar age = 45;\n\n// There is no integer type, so there is no\n// worry of integer division (python 2)\n// or integer overflow\nconsole.log(\"45 = \", 45);\nconsole.log(\"45.0 = \", 45.0);\n\n// Scientific notation is achieved with 'e'\n// xey = x * 10^y\nconsole.log(\"1e+1 = \", 1e+1);\nconsole.log(\"1e+2 = \", 1e+2);\nconsole.log(\"1e-2 = \", 1e-2);\n\n// Javascript also defines any number larger\n// than 1.7976931348623157e+308 as infinity\nconsole.log(1.79769313486231570e+308);\nconsole.log(\"Anything >= 1.8e+308 = \", 1.8e+308);");

  slide.code("JavaScript Variables: Strings", null, "// Strings work about the same as python\n// You can use \" \" or '' to define them:\nvar name = \"Bojack\";\nvar lastName = 'Horseman';\n\n// We can concatenate strings with + \nconsole.log(name + \" \" + lastName);\n\n// And \\ is the escape character \nconsole.log(name + \" is \\\"great\\\"\");\n\n// We can also mix quotes for the same effect\nconsole.log(name + ' is \"great\"');\n\n// Multi-line strings require you escape\n// the carridge-return:\nconsole.log(\"Multi \\\n.............Line\");\n\n// We can also use + to convert strings to numbers\nvar numString = +\"55\";\nconsole.log(numString + 1);\n\nvar stringNum = \"55\";\nconsole.log(stringNum + 1);\n\n// We can also check the type of a variable\n// with the typeof operator\nconsole.log(\"numString is a \" + typeof numString);\nconsole.log(\"stringNum is a \" + typeof stringNum);");

  slide.code("JavaScript Arrays", null, "// Arrays are squences of elements with integer\n// property names:\n\nvar empty = [];\n\nvar numbers = [\n   'zero', 'one', 'two', 'three', 'four',\n   'five', 'six', 'seven', 'eight', 'nine'\n];\n\nconsole.log(\"empty[1] = \" + empty[1]);\nconsole.log(\"numbers[1] = \", numbers[1]);\n\n// We can also index with strings\nconsole.log(\"numbers['1'] = \", numbers['1']);\n\n// Arrays can hold any mixture of values\nvar misc = [\n       'string', 98.6, true, false, null, undefined,\n       ['nested', 'array'], {object: true}, NaN,\n       Infinity\n   ];\n\n// Arrays also have a useful length attribute\nconsole.log(\"empty.length = \" + empty.length);\nconsole.log(\"numbers.length = \" + numbers.length);\nconsole.log(\"misc.length = \" + misc.length);");

  slide.code("JavaScript Array Methods", null, "// Arrays have a set of methods which are included:\nvar a = ['a', 'b', 'c'];\nvar b = ['x', 'y', 'z'];\n\n// Concat:\nvar c = a.concat(b, true);\nconsole.log(\"a.concat(b, true) = \", c);\n\n// Pop:\nvar c = a.pop();\nconsole.log(\"a.pop() =\", c);\nconsole.log(\"a = \", a);\n\n// Push:\nvar c = a.push('d');\nconsole.log(\"a.push() =\", c); // new length\nconsole.log(\"a = \", a);\n\n// Slice:\nvar a = [1,2,3,4,5,6];\nvar a_end = a.slice(2);\nvar a_mid = a.slice(2,4);\nconsole.log(\"a.slice(2): \", a_end);\nconsole.log(\"a.slice(2,4): \" + a_mid);\n\n// Filter:\nvar a = [1,4,8,10,3,12,2];\nvar a_big = a.filter(function (d) {return d > 9;});\nconsole.log(\"a.filter(function (d) {return d > 9;}) = \", a_big);\n\n// And many more...\n// array.reverse()\n// array.sort()\n// array.shift()\n// array.splice()");

  slide.code("JavaScript Objects", null, "// Objects are defined with curly braces \n// surrounding zero or more name/value pairs\nvar empty_object = {};\n\n// Names can be specified with or without quotes\nvar actor = {\n     \"first-name\": \"Bojack\",\n     last_name: \"Horseman\"\n     };\n\n// Values can be anything, including objects\nvar course = {\n    title: \"Data Visualization\",\n    dept: \"DSE\",\n    number: 241,\n    professor: {\n        first_name: \"Amit\",\n        last_name: \"Chourasia\"\n      }\n  };\n\n// Values are retrieved by wrapping the string\n// name in [] or using . notation for legal\n// Javascript names\nconsole.log(actor[\"first-name\"], actor.last_name);\nconsole.log(course.title, course.number);\n");

  slide.code("JavaScript Objects", null, "var course = {\n    title: \"Data Visualization\",\n    dept: \"DSE\",\n    number: 241,\n    professor: {\n        first_name: \"Amit\",\n        last_name: \"Chourasia\"\n      }\n  };\n\n// Object properties can be replaced\ncourse.title = \"Computer Stuff\";\n\n// Or if they dont exist, they will be created\ncourse.room = \"Dungeon\";\nconsole.log(\"course.room:\", course.room);\n\n// Also note objects are always passed by \n// reference and never copied\nvar course2 = course;\ncourse2.room = \"Above Ground!\"\n\nconsole.log(\"course.room: \", course.room);\nconsole.log(\"course2.room: \", course2.room);\n\n// Properties can be deleted\ndelete course.room;");

  slide.code("Operations and Comparisons", null, "// Application of operators follows standard\n// order of operations:\n// . [] ()       Accessing & grouping\n// * / %         Mul, Div, Mod\n// + -           Add, Subtract\n// >= <= > <     Ineqality\n// === !==       Equal-to, NEQ\n// &&            Logical AND\n// ||            Logical OR\n// ?:            Ternary\nconsole.log(6*10 + 5 * (2 - 3));\n\nvar divByZero = 100.0 / 0.0;\nvar zeroOverZero = 0.0 / 0.0;\n\nconsole.log(\"100.0 / 0.0 = \" + divByZero);\nconsole.log(\"0.0 / 0.0 = \" + zeroOverZero);\n\n// Equality returns booleans\nconsole.log(\"5 === 5: \", 5 === 5);\nconsole.log(\"5 === 6: \", 5 === 6);\nconsole.log(\"5 === '5': \", 5 === '5');\n\n// Don't use == for equality...\nconsole.log('\\t\\r\\n ' == 0);\n\n// === checks strick equality\n// == performs type conversion \n\n// Can check for NaN with isNaN()\nconsole.log(\"isNaN(zeroOverZero):\",\n              isNaN(zeroOverZero));\n\n");

  slide.code("JavaScript Control Flow", null, "var a = [0, 1, 2, 3, 4];\nvar singer = {\n    first_name: \"Kanye\",\n    last_name: \"West\"\n}\n\n\n// If (ALWAYS USE {} BRACES)\nif (a[3] === 3) {\n  console.log(\"if: success\");\n}\nelse {\n  console.log(\"if: failure\");\n}\n\n// For (enumeration)\nfor (var i = 0; i < a.length; i++) {\n  console.log(\"a[\" + i + \"] = \" + a[i]);\n}\n\n// For (attr in obj)\nfor (var prop in singer) {\n  console.log(\"singer[\" + prop + \"] = \", \n                          singer[prop])\n}\n\n// While \nwhile (a[4] > 2) {\n  a[4]--;\n  console.log(\"a[4] = \" + a[4]);\n}\n\n// Also notice the increment and \n// decrement operators ++, --\n");

  slide.code("JavaScript Functions", null, "// Functions are JavaScript objects\n\n// Create a variable called add and store\n// a function in it that adds two numbers.\nvar add = function (a, b) { \n  return a + b;\n};\n\nconsole.log(\"add(2,3) = \", add(2,3));\n\n// Since functions are objects, they can be stored\n// as 'methods' within other objects\n\n// As Methods, they always recieve the 'this'\n// argument when invoked, which is bound \n// to the object they are a method of\nvar myObject = {\n   value: 0,\n   increment: function (inc) {\n       this.value += inc;\n    } \n};\n\nconsole.log(\"myObject.value: \", myObject.value);\nmyObject.increment(2);\nconsole.log(\"myObject.value: \", myObject.value);");

  slide.code("JavaScript Functions", null, "// Functions are JavaScript objects\n\n// Create a variable called add and store\n// a function in it that adds two numbers.\nvar add = function (a, b) { \n  return a + b;\n};\n\n// Can also specify function names directly\nfunction sub(a, b) { \n  return a - b;\n}; \n\nconsole.log(\"add(2,3) = \", add(2,3));\nconsole.log(\"sub(2,3) = \", sub(2,3));\n\n// Since functions are objects, they can be stored\n// as 'methods' within other objects\n\n// As Methods, they always recieve the 'this'\n// argument when invoked, which is bound \n// to the object they are a method of\nvar myObject = {\n   value: 0,\n   increment: function (inc) {\n       this.value += inc;\n    } \n};\n\nconsole.log(\"myObject.value: \", myObject.value);\nmyObject.increment(2);\nconsole.log(\"myObject.value: \", myObject.value);");

  slide.title("Theres even more important parts of JavaScript that could help you, like Closures and Inheritance, but for now this is enough. Check out 'JavaScript: The Good Parts' for more.");

  slide.title("Now some D3...");

  slide.code("Selections: d3.select()", null, "// d3.select(\"selector\") scans the html document\n// and returns the first instance of 'selector'\n// it finds, where 'selector' is a CSS selector\n\n// Since these slides have a \n// <div class=\"out output\"></div>   ----->>>>\n// we select that to work with\n\nvar output_div = d3.select('div.out.output');\n\n// We can then set CSS style of the selected\n// element with .style('name', value)\n\noutput_div.style('background-color', 'blue');\n\n// We can modify all other non-style attributes\n// like 'class' and 'id' with .attr()\n\noutput_div.attr('id', 'main_output');\n");

  slide.code("Adding DOM elements with D3", null, "// First we select the output div \nvar output_div = d3.select('div.output');\n\n// Use .append() to add a DOM element to \n// the end of the selected div\nvar svg = output_div.append('svg');\n\n// Use .attr() to set element attributes\nsvg.attr(\"width\", 400);\nsvg.attr(\"height\", 300);\n\n// Elements can be added within other elements\n// Add a circle to the svg canvas\nvar circle = svg.append(\"circle\");\ncircle.attr(\"cx\", 40);\ncircle.attr(\"cy\", 60);\ncircle.attr(\"r\", 30);\n");

  slide.code("Chaining D3 methods", null, " // D3 .append(), .attr(), and .style() \n // all return the element or elements\n // they operated on, so they can be chained\n // as follows:\n\nvar svg = d3.select('div.output')\n   .append('svg')\n   .attr(\"width\", 400)\n   .attr(\"height\", 300);\n\n // Add a circle\n svg.append(\"circle\")\n   .attr(\"class\", \"myCircles\")\n   .attr(\"id\", \"circle_top\")\n   .attr(\"cx\", 40)\n   .attr(\"cy\", 60)\n   .attr(\"r\", 30);\n\n // Add second circle\n svg.append(\"circle\")\n   .attr(\"class\", \"myCircles\")\n   .attr(\"id\", \"circle_bottom\")\n   .attr(\"cx\", 40)\n   .attr(\"cy\", 120)\n   .attr(\"r\", 20);\n\n // Add a rectangle\n svg.append(\"rect\")\n   .attr(\"x\", 100)\n   .attr(\"y\", 60)\n   .attr(\"width\", 30)\n   .attr(\"height\", 50)\n   .style(\"fill\", \"orange\");\n\n // Add a line\n svg.append(\"line\")\n   .attr(\"x2\", 250)\n   .attr(\"y2\", 90)\n   .attr(\"x1\", 150)\n   .attr(\"y1\", 60)\n   .attr(\"stroke\", \"black\")\n   .attr(\"stroke-width\", 2);");

  slide.title("Check out the same example <a href=\"./../Basic_Files/basic_d3.html\" >here</a><br/> Right Click and view the source code to understand  how to use d3 inside HTML ");

  slide.title("Once added, DOM elements can be selected and modified with D3");

  slide.code("SVG Selections", shapes, "/* Given an output div like:\n<div class=\"out output\">\n <svg height=\"300\" width=\"400\">\n   <circle r=\"30\" cy=\"60\" cx=\"40\" \n     id=\"circle_top\" class=\"myCircles\"></circle>\n   <circle r=\"20\" cy=\"120\" cx=\"40\"\n     id=\"circle_bottom\" class=\"myCircles\"></circle>\n   <rect style=\"fill: orange;\" height=\"50\"\n      width=\"30\" y=\"60\" x=\"100\"></rect>\n   <line stroke-width=\"2\" stroke=\"black\" \n       y1=\"60\" x1=\"150\" y2=\"90\" x2=\"250\"></line>\n </svg>\n</div>\n*/\n\n// We can select DOM elements with selector\n// strings (Same as CSS: elem, .class, #id)\nvar circle = d3.select(\"div.output svg\")\n              .select(\"#circle_top\");\n\n// We can also sub-select from selections \nvar rect = d3.select(\"div.output\")\n             .select(\"rect\");\n\n// We can then act on these selections\ncircle.attr(\"fill\", \"red\");\nrect.style(\"fill\", \"purple\");");

  slide.code("Multiple Selections: .selectAll()", shapes, "/* Given an output div like:\n<div class=\"out output\">\n <svg height=\"300\" width=\"400\">\n   <circle r=\"30\" cy=\"60\" cx=\"40\" \n     id=\"circle_top\" class=\"myCircles\"></circle>\n   <circle r=\"20\" cy=\"120\" cx=\"40\"\n     id=\"circle_bot\" class=\"myCircles\"></circle>\n   <rect style=\"fill: orange;\" height=\"50\"\n      width=\"30\" y=\"60\" x=\"100\"></rect>\n   <line stroke-width=\"2\" stroke=\"black\" \n       y1=\"60\" x1=\"150\" y2=\"90\" x2=\"250\"></line>\n </svg>\n</div>\n*/\n\n// We can also select ALL elements which match \nvar circle = d3.selectAll(\".myCircles\");\n\n// We can then act on all these selections\n// simultaneously\ncircle.style(\"fill\", \"steelblue\");");

  slide.code("Acting on Selections Individually", shapes, "/* Given an output div like:\n <div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"30\" cy=\"60\" cx=\"40\" \n      id=\"circle_top\" class=\"myCircles\"></circle>\n    <circle r=\"20\" cy=\"120\" cx=\"40\"\n      id=\"circle_bot\" class=\"myCircles\"></circle>\n    <rect style=\"fill: orange;\" height=\"50\"\n       width=\"30\" y=\"60\" x=\"100\"></rect>\n    <line stroke-width=\"2\" stroke=\"black\" \n        y1=\"60\" x1=\"150\" y2=\"90\" x2=\"250\"></line>\n  </svg>\n</div>\n*/\n\n // Typicall, when selecting SVG elements, we \n // want to select from the SVG canvas to avoid\n // conflicts\n var svg = d3.select(\"div.output\");\n\n // Select all circles\n var circle = svg.selectAll(\"circle\");\n\n // Use an anonymous function which gets\n // evaluated for each element in the selection\n // to set the x coordinate\n circle.attr(\"cx\", function () { \n          return Math.random() * 400;\n          });");

  slide.title("The magic of D3 allows us to then set these element properties based on data");

  slide.code("Binding Data: .data()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n// Select the SVG canvas\nvar svg = d3.select(\"div.output svg\");\n\n// Select all three circles\nvar circle = svg.selectAll(\"circle\");\n\n// Define our data\nvar dataset = [25, 400, 900];\n\n// Bind the circles to data of our choice\n// based on index\ncircle.data(dataset);\n\n// After the data is bound, it lives\n// in the .__data__ property of the \n// DOM element (CHECK INSPECTOR)\n\n// This data is then available as the \n// first argument to .attr() and .style()\n// functions (by convention we use d)\ncircle.attr(\"r\", function (d) { \n        return Math.sqrt(d);\n        });");

  slide.code("Binding Data: .data()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n // Select the SVG canvas\n var svg = d3.select(\"div.output svg\");\n\n // Select all three circles\n var circle = svg.selectAll(\"circle\");\n\n // Define the data\n var dataset = [25, 400, 900];\n\n // Bind the circles to data of our choice\n // based on index\n circle.data(dataset);\n\n // After the data is bound, it lives\n // in the .__data__ property of the \n // DOM element (CHECK INSPECTOR)\n\n // This data is then available as the \n // first argument to .attr() and .style()\n // functions (by convention we use d)\n circle.attr(\"r\", function (d) { \n          return Math.sqrt(d);\n          });\n\n // The second argument is the index of the \n // element (by convention we use i)\n circle.attr(\"cy\", function (d, i) {\n      return i * 100 + 150;\n  });");

  slide.title("We can even create new elements for new data");

  slide.code("Entering Elements: .enter()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n // What if we try to bind 4 data points\n // instead of 3 like last time?\n var dataset = [25, 400, 900, 1600];\n\n // Select the SVG canvas\n var svg = d3.select(\"div.output svg\");\n\n // Select all three circles & bind to\n // our four data points\n var circle = svg.selectAll(\"circle\")\n              .data(dataset);\n\n // Change radius of existing circles based on data\n circle.attr(\"r\", function (d) { \n          return Math.sqrt(d);\n      })\n\n // Then use .enter() to create & select\n // placeholder elements for which we have data \n // but no existing element (datapoint 1600)\n var circleEnter = circle.enter();\n\n // Add a circle for each new data point\n var newCircles = circleEnter.append(\"circle\");\n\n // Now set the properties of the new circle\n newCircles.attr(\"r\", function (d) { \n          return Math.sqrt(d);\n      })\n      .attr(\"cx\", function (d, i) {\n          return i * 100 + 40;\n        })\n      .attr(\"cy\", 60)\n      .style(\"fill\", \"red\");");

  slide.code("ENTER EVERYTHING", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n// We can now create elements for all new data\n\n// Select the SVG canvas\nvar svg = d3.select(\"div.output svg\");\n\nvar dataset = [25, 400, 900, 1600];\n\n// Select circles & bind to\n// our four data points\nvar circle = svg.selectAll(\"circle\")\n            .data(dataset);\n\n// Entering now returns all data\nvar circleEnter = circle.enter();\n\n// Add a circle for each new data point\nvar newCircles = circleEnter.append(\"circle\");\n\n// Now set the properties of the new circles\nnewCircles.attr(\"r\", function (d) { \n        return Math.sqrt(d);\n    })\n    .attr(\"cx\", function (d, i) {\n        return i * 100 + 40;\n    })\n    .attr(\"cy\", 60);");

  slide.code("ENTER EVERYTHING: The pattern", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n// Select the SVG canvas\nvar svg = d3.select(\"div.output svg\");\n\n// Define the data\nvar dataset = [25, 400, 900, 1600];\n\n// Bind - Enter - Update\nsvg.selectAll(\"circle\")\n    .data(dataset)\n    .enter()\n    .append(\"circle\")\n    .attr(\"r\", function (d) { \n      return Math.sqrt(d);\n    })\n    .attr(\"cx\", function (d, i) {\n        return i * 100 + 40;\n      })\n    .attr(\"cy\", 60);");

  slide.title("And remove elements for missing data");

  slide.code("Exiting Elements: .exit()", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n// What if we instead give the visualization\n// only 2 data points?\nvar dataset = [25, 400];\n\n// Select the SVG canvas\nvar svg = d3.select(\"div.output svg\");\n\n// Select all three circles & bind to\n// our two data points\nvar circle = svg.selectAll(\"circle\")\n            .data(dataset);\n\n// Change radius of existing circles based on data\ncircle.attr(\"r\", function (d) { \n        return Math.sqrt(d);\n    })\n\n// Here .exit() returns the elements for which\n// no corresponding data point was bound.\ncircle.exit().remove();\n\n// If the data doesnt exist, remove the circle!");

  slide.title("To assist visualization, D3 provides scales to convert from a specified domain to a specified range");

  slide.code("Scales", null, "// Given a canvas width and height\nvar w = 420, h = 320;\n\n// We use d3.scaleLinear() to \n// return a function which converts\n// from our data domain to the \n// canvas pixel domain\n\n// x is a function!\nvar x = d3.scaleLinear()\n  // Domain is input\n  .domain([-1, 1])\n  // Range is output\n  .range([0, w])\n\n// y is also a function!\nvar y = d3.scaleLinear()\n  .domain([0, 1000])\n  .range([0, h])\n\nconsole.log(\"x(-1) ==\", x(-1)) // == 0\nconsole.log(\"x(0) ==\", x(0)) // == w/2\nconsole.log(\"x(1) ==\", x(1)) // == w\n\nconsole.log(\"y(900) ==\", y(900)) // == h*9/10\n");

  slide.code("A basic scaled barchart", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\nvar svg = d3.select(\"div.output svg\");\n\nvar data = [4, 8, 15, 16, 23, 42];\n\nvar width = 500,\n    height = 666;\n\n// Define the bar thickness to be an even\n// division of the svg height\nvar barHeight = height / data.length;\n\n// Create an xScale which maps from data\n// values to x coordinates\nvar xScale = d3.scaleLinear()\n    .domain([0, d3.max(data)])\n    .range([0, width]);\n\n// For each data point, create a group\n// which translates all elements to the \n// correct y coordinate\nvar bar = svg.selectAll(\"g\")\n    .data(data)\n  .enter().append(\"g\")\n    .attr(\"transform\", function(d, i) { \n      return \"translate(0,\" + i * barHeight + \")\"; \n    });\n\n// bar now holds all newly created groups\n\n// Add an SVG rect of width = xScale(datum)\nbar.append(\"rect\")\n    .attr(\"width\", function (d) { \n      return xScale(d); \n    })\n    .attr(\"height\", barHeight - 1)\n    .style(\"fill\", \"steelblue\")\n    .style(\"stroke\", \"white\");\n\n// Add SVG text the end of the bar displaying\n// the value of the data\nbar.append(\"text\")\n    .attr(\"x\", function(d) { \n        return xScale(d) - 5; \n    })\n    .attr(\"y\", barHeight / 2)\n    .attr(\"dy\", \".35em\")\n    .text(function(d) { return d; })\n    .style(\"fill\", \"white\")\n    .style(\"text-anchor\", \"end\");");

  slide.code("Flipping the barchart", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\nvar svg = d3.select(\"div.output svg\");\n\nvar data = [4, 8, 15, 16, 23, 42];\n\nvar width = 500,\n    height = 666,\n    barWidth = width / data.length - 10;\n\nvar y_scale = d3.scaleLinear()\n    .domain([0, d3.max(data)])\n    .range([0, height]);\n\nvar x_scale = d3.scaleLinear()\n    .domain([0, data.length])\n    .range([0, width]);\n\n// Create a bar for each data point\nvar bar = svg.selectAll(\"rect\")\n    .data(data)\n  .enter().append(\"rect\")\n    .attr(\"x\", function (d, i) { \n      return x_scale(i); \n    })\n    .attr(\"y\", function (d) { \n      return height - y_scale(d); \n    })\n    .attr(\"width\", barWidth)\n    .attr(\"height\", function (d) { \n      return y_scale(d); \n    })\n    .style(\"fill\", \"steelblue\")\n    .style(\"stroke\", \"white\");\n\n// Create a text label for each data point\nsvg.selectAll(\"text\")\n    .data(data)\n    .enter().append(\"text\")\n    .attr(\"x\", function(d, i) { \n        return x_scale(i) + barWidth / 2; \n    })\n    .attr(\"y\", function (d) { \n      return height - y_scale(d) + 20; \n    })\n    .text(function(d) { return d; })\n    .style(\"fill\", \"white\")\n    .style(\"text-anchor\", \"middle\");");

  slide.code("Basic Scatterplot", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n// Select the svg canvas\nvar svg = d3.select(\"div.output svg\");\n\nvar data = \n  [[5, 20], [480, 90], [250, 50], [100, 33], [330, 95],\n   [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]];\n\nvar width = 500,\n    height = 666;\n\n// Compute the maximum values for the scales\nvar x_max = d3.max(data, function(d) {\n        return d[0];\n    });\n\nvar y_max = d3.max(data, function (d) {\n      return d[1];\n    });\n\n// Define two linear scales for the \n// x & y values\nvar x_scale = d3.scaleLinear()\n    .domain([0, x_max])\n    .range([0, width]);\n\nvar y_scale = d3.scaleLinear()\n    .domain([0, y_max])\n    .range([0, height]);\n\n// Bind - enter - update circles with\n// coordinates given by the scaled data\nsvg.selectAll(\"circle\") \n   .data(data)\n   .enter()\n   .append(\"circle\")\n   .attr(\"cx\", function(d) {\n        return x_scale(d[0]);\n   })\n   .attr(\"cy\", function(d) {\n        return y_scale(d[1]);\n   })\n   .attr(\"r\", 5);");

  slide.code("Basic Histogram", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n//generate random data\nvar data = d3.range(1000).map(d3.randomBates(10));\n\nvar formatCount = d3.format(\",.0f\");\n\n//Initialize width, height. Select SVG and add svg group \"g\"\nvar svg = d3.select(\"div.output svg\"),\n    margin = {top: 20, right: 30, bottom: 30, left: 30},\n    width = 500 - margin.left - margin.right,\n    height = +svg.attr(\"height\") - margin.top - margin.bottom,\n    g = svg.append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n//Define XScales\nvar x = d3.scaleLinear()\n    .rangeRound([0, width]);\n\n//Define Histogram bins\nvar bins = d3.histogram()\n    .domain(x.domain())\n    (data);\n\n//Define YScales using bins\nvar y = d3.scaleLinear()\n    .domain([0, d3.max(bins, function(d) { return d.length; })])\n    .range([height, 0]);\n\n//Generate Histogram\nvar bar = g.selectAll(\".bar\")\n  .data(bins)\n  .enter().append(\"g\")\n    .attr(\"class\", \"bar\")\n    .attr(\"transform\", \n      function(d) { return \"translate(\" + x(d.x0) + \",\" + y(d.length) + \")\"; });\n\nbar.append(\"rect\")\n    .attr(\"x\", 1)\n    .attr(\"width\", x(bins[0].x1) - x(bins[0].x0) - 1)\n    .attr(\"height\", function(d) { return height - y(d.length); })\n    .style(\"fill\",\"lightblue\");\n\nbar.append(\"text\")\n    .attr(\"dy\", \"-.75em\")\n    .attr(\"y\", 6)\n    .attr(\"x\", (x(bins[0].x1) - x(bins[0].x0)) / 2)\n    .attr(\"text-anchor\", \"middle\")\n    .text(function(d) { return formatCount(d.length); });\n\ng.append(\"g\")\n    .attr(\"class\", \"axis axis--x\")\n    .attr(\"transform\", \"translate(0,\" + height + \")\")\n    .call(d3.axisBottom(x));");

  slide.title("D3 also makes animations between properties easy");

  slide.code("Basic Transition", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n // Select the SVG canvas\n var svg = d3.select(\"div.output svg\");\n\n// Select our circles and bind new data\nvar circle = svg.selectAll(\"circle\")\n            .data([25, 400, 900]);\n\n// Apply transition of duration 2 seconds\n// and update properties of all circles \n// based on new data\ncircle.transition()\n      .duration(2000)\n      .attr(\"r\", function (d) { \n        return Math.sqrt(d);\n      })\n      .attr(\"cx\", function (d, i) {\n          return i * 100 + 40;\n      })\n      .attr(\"cy\", function (d, i) {\n          return i * 100 + 150;\n      });");

  slide.code("Transitions For New Elements", circles3, "/* Given an output div like:\n<div class=\"out output\">\n  <svg height=\"300\" width=\"400\">\n    <circle r=\"10\" cy=\"60\" cx=\"40\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"140\"></circle>\n    <circle r=\"10\" cy=\"60\" cx=\"240\"></circle>\n  </svg>\n</div>\n*/\n\n// Select the SVG canvas\n var svg = d3.select(\"div.output svg\");\n\n// Select our circles and bind new data\nvar circle = svg.selectAll(\"circle\")\n            .data([25, 400, 900, 1600]);\n\n// Define initial properties for new circle\n// Apply transition of duration 2 seconds\n// and update properties of all circles \n// based on data\ncircle.enter()\n  .append(\"circle\")\n  .attr(\"r\", 0)\n  .attr(\"cx\", 400)\n  .attr(\"cy\", 300)\n  .style(\"fill\", \"red\")\n      .merge(circle) \n\n      // allows transition to be applied on the newly entered circle \n          .transition()\n          .duration(2000)\n          .attr(\"r\", function (d) { \n            return Math.sqrt(d);\n          })\n          .attr(\"cy\", function (d, i) {\n              return i * 100 + 150;\n          });");

  slide.code("Transitioning in the barchart", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\nvar svg = d3.select(\"div.output svg\");\n\nvar data = [4, 8, 15, 16, 23, 42];\n\nvar width = 500,\n    height = 666,\n    barWidth = width / data.length - 10;\n\nvar y_scale = d3.scaleLinear()\n    .domain([0, d3.max(data)])\n    .range([0, height]);\n\nvar x_scale = d3.scaleLinear()\n    .domain([0, data.length])\n    .range([0, width]);\n\n// Create a bar for each data point\nvar bar = svg.selectAll(\"rect\")\n    .data(data)\n  .enter().append(\"rect\")\n    .attr(\"x\", function (d, i) { \n      return x_scale(i); \n    })\n    .attr(\"y\", function (d) { \n      return height; \n    })\n    .attr(\"width\", barWidth)\n    .attr(\"height\", function (d) { \n      return y_scale(d); \n    })\n    .style(\"fill\", \"steelblue\")\n    .style(\"stroke\", \"white\");\n\n// Transition to the correct y location\nbar.transition().duration(2000)\n    .attr(\"y\", function (d) { \n      return height - y_scale(d); \n    });\n\n// Create a text label for each data point\nvar text = svg.selectAll(\"text\")\n    .data(data)\n    .enter().append(\"text\")\n    .attr(\"x\", function(d, i) { \n        return x_scale(i) + barWidth / 2; \n    })\n    .attr(\"y\", height)\n    .text(function(d) { return d; })\n    .style(\"fill\", \"white\")\n    .style(\"text-anchor\", \"middle\");\n\n// Transition text to correct height\ntext.transition().duration(2000)\n    .attr(\"y\", function (d) { \n      return height - y_scale(d) + 20; \n    });");

  slide.title("Binding data by key");

  slide.code_title(title = ".data(..., join)");

  init_svg = function() {
    var svg;
    svg = d3.select("div.output").append("svg");
    return svg.selectAll("rect").data([127, 61, 256]).enter().append("rect").attr("x", 0).attr("y", function(d, i) {
      return i * 90 + 50;
    }).attr("width", function(d, i) {
      return d;
    }).attr("height", 20).style("fill", "steelblue");
  };

  slide.code(title, init_svg, "var svg = d3.select(\"div.output svg\")\n\n// Let's say we start here:\n/*\nsvg.selectAll(\"rect\")\n  .data([127, 61, 256])\n  .enter().append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", function(d,i) { return i*90+50 })\n    .attr(\"width\", function(d,i) { return d; })\n    .attr(\"height\", 20)\n    .style(\"fill\", \"steelblue\")\n*/\n\n// And then we bind new data by index\nvar selection = svg.selectAll(\"rect\")\n  .data([61, 256, 71]) \n\n// Create rectangles for new data (NONE)\nselection.enter().append(\"rect\")\n  .attr(\"x\", 0)\n  .attr(\"y\", function(d,i) { return i*90+50 })\n  .attr(\"width\", function(d,i) { return d; })\n  .attr(\"height\", 20)\n  .style(\"fill\", \"steelblue\")\n// Transition old rectangles to new y and \n// width based on the new data\n    .merge(selection)\n      .transition()\n      .duration(3000)\n        .attr(\"x\", 0)\n        .attr(\"y\", function(d,i) { return i*90+50 })\n        .attr(\"width\", function(d,i) { return d; })\n        .attr(\"height\", 20)\n        .style(\"fill\", \"steelblue\")\n\n// Remove rectangles for which we have no bound\n// data (NONE since we bound by index)\nselection.exit()\n  .remove()");

  slide.title("Loading External Data");

  slide.code("d3.csv()", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"666\" width=\"500\"></svg>\n</div>\n*/\n\n/* And a datafile data.csv:\n      name,value\n      Locke,4\n      Reyes,8\n      Ford,15\n      Jarrah,16\n      Shephard,23\n      Kwon,42\n*/\n\nvar width = 450,\n    height = 666;\n\nvar x = d3.scaleLinear()\n    .range([0, width]);\n\nvar chart = d3.select(\"div.output svg\");\n\n// d3.csv takes 3 arguments:\n// filename, accessor, callback\n\n// The accessor is a function which takes \n// each row of the data and returns a converted\n// version:\nfunction type(d) {\n  d.value = +d.value; // coerce to number\n  return d;\n}\n\n// This converted version is passed to the\n// third argument, the callback function\n// All processing happens inside this function\n\nd3.csv(\"data/data.csv\", type,\n  function(error, data) {\n  // Stop d3.csv() from failing to load silently\n  if (error) { console.log(error);}\n\n  var barHeight = height / data.length;\n\n  x.domain([0, d3.max(data, function(d) {\n     return +d.value; \n     })]);\n\n  chart.attr(\"height\", barHeight * data.length);\n\n  var bar = chart.selectAll(\"g\")\n      .data(data)\n    .enter().append(\"g\")\n      .attr(\"transform\", function(d, i) { \n          return \"translate(0,\" + i * barHeight + \")\";\n        });\n\n  bar.append(\"rect\")\n      .attr(\"width\", function(d) { \n          return x(d.value); \n       })\n      .attr(\"height\", barHeight - 1);\n\n  bar.append(\"text\")\n      .attr(\"x\", function(d) { \n          return x(d.value) - 25; \n      })\n      .attr(\"y\", barHeight / 2)\n      .attr(\"dy\", \".35em\")\n      .text(function(d) { \n        return d.value; \n      });\n});\n");

  slide.title("D3 Data Processing");

  slide.code("d3.nest()", null, "// Given an yields of items\nvar yields = [\n  {yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1932, site: \"Morris\"},\n  {yield: 27.43, variety: \"Chowmein\", year: 1932, site: \"Morris\"},\n  {yield: 27.00, variety: \"Manchuria\", year: 1932, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Dumpling\", year: 1933, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1933, site: \"Morris\"},\n  {yield: 27.43, variety: \"Chowmein\", year: 1935, site: \"Morris\"}\n];\n\n//Nesting allows elements in an array to \n//be grouped into a hierarchical tree structure; \n// Think of it like the GROUP BY operator in SQL\nvar entries = d3.nest()\n    .key(function(d) { return d.year; })\n    .entries(yields);\n\n//Print JSON in pretty format\nconsole.log(JSON.stringify(\n                 entries,undefined,2))");

  slide.code("d3.nest() rollup", null, "// Given an yields of items\nvar yields = [\n  {yield: 27.00, variety: \"Manchuria\", year: 1931, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Manchuria\", year: 1931, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1932, site: \"Morris\"},\n  {yield: 27.43, variety: \"Chowmein\", year: 1932, site: \"Morris\"},\n  {yield: 27.00, variety: \"Manchuria\", year: 1932, site: \"University Farm\"},\n  {yield: 48.87, variety: \"Dumpling\", year: 1933, site: \"Waseca\"},\n  {yield: 27.43, variety: \"Manchuria\", year: 1933, site: \"Morris\"},\n  {yield: 27.43, variety: \"Chowmein\", year: 1935, site: \"Morris\"}\n];\n\n//Nesting allows elements in an array to \n//be grouped into a hierarchical tree structure; \n// Think of it like the GROUP BY operator in SQL\nvar entries = d3.nest()\n    .key(function(d) { return d.year; })\n    .key(function(d) { return d.variety; })\n    .rollup(function(d) { return d.length; })\n    .entries(yields);\n\n//Print JSON in pretty format\nconsole.log(JSON.stringify(\n                 entries,undefined,2))");

  slide.title("Check more on nesting <a target=\"_blank\" href=\"https://github.com/d3/d3-collection#nests\">here</a>");

  slide.title("Advanced Scales");

  slide.code("Advanced Scales", empty_svg, "var w = 450,\n    h = 500;\n\nvar years = [\"1992\", \"1996\", \"2000\", \"2004\"];\nvar positions = [100, 200, 300, 400];\n\n// Ordinal scales map discrete values by index\nvar xScale = d3.scaleOrdinal()\n                .domain(years)\n                .range(positions);\n\nconsole.log(\"xScale('2000'): \", xScale(\"2000\"));\n\n// ScaleBands are like ordinal scales except \n// the output range is continuous and numeric.\n// rangeRound() create the range by diving the given interval into \n// bands of even size (with rounded values)\n\nvar xScale =  d3.scaleBand()\n                .domain(years)\n                .rangeRound([0, w])\n                .padding(0.05)\n\nconsole.log(\"xScale('2000'): \", xScale(\"2000\"));\n\n// There is also a .bandwidth() method which \n// returns the size of the band\nconsole.log(\"xScale.bandwidth(): \", \n              xScale.bandwidth());");

  slide.title("Adding Axes");

  slide.code("Adding Axes", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"600\" width=\"500\"></svg>\n</div>\n*/\n\n// Select the SVG canvas\nvar svg = d3.select('div.output svg');\n\n// Given a canvas width and height\nvar w = 500, h = 600, padding = 100;\n\n// First get the scales\nvar xScale = d3.scaleLinear()\n  .domain([-1, 1])\n  .range([0, w])\n\nvar yScale = d3.scaleLinear()\n  .domain([0, 1000])\n  .range([0, h])\n\n/* Define the axes using axes\norientation and scale functions\nFor orientation we use:\naxisLeft,axisRight,axisTop or axisBottom\n*/\nvar xAxis = d3.axisBottom(xScale);  \nvar yAxis = d3.axisLeft(yScale);\n\n// To actually draw the SVG axis to the screen\n// we have to say 'where' and give it something\n// to be drawn in (like a <g> tag). We then use\n// .call() to call the Axis drawing functions\nsvg.append(\"g\")\n    .attr(\"transform\", \"translate(0,\" + h + \")\")\n    .call(xAxis);\n\nsvg.append(\"g\")\n    .attr(\"transform\", \"translate(\" + padding + \", 0)\")\n    .call(yAxis);\n");

  slide.title("Interesting Examples");

  slide.code("Force-Directed Graph", empty_svg, "/* Given a div with an empty SVG canvas:\n<div class=\"out output\">\n    <svg height=\"600\" width=\"500\"></svg>\n</div>\n*/\n\nvar svg = d3.select(\"div.output\").select(\"svg\"),\n    width = +svg.attr(\"width\"),\n    height = +svg.attr(\"height\");\n\nvar color = d3.scaleOrdinal(d3.schemeCategory20);\n\nvar simulation = d3.forceSimulation()\n    .force(\"link\", d3.forceLink().id(function(d) { return d.id; }))\n    .force(\"charge\", d3.forceManyBody())\n    .force(\"center\", d3.forceCenter(width / 2, height / 2));\n\nd3.json(\"data/miserables.json\", function(error, graph) {\n  if (error) throw error;\n\n  var link = svg.append(\"g\")\n      .attr(\"class\", \"links\")\n    .selectAll(\"line\")\n    .data(graph.links)\n    .enter().append(\"line\")\n      .attr(\"stroke-width\", \n              function(d) { return Math.sqrt(d.value); })\n      .attr(\"stroke\",\"#999\");\n\n  var node = svg.append(\"g\")\n      .attr(\"class\", \"nodes\")\n    .selectAll(\"circle\")\n    .data(graph.nodes)\n    .enter().append(\"circle\")\n      .attr(\"r\", 5)\n      .attr(\"fill\", function(d) { return color(d.group); })\n      .call(d3.drag()\n          .on(\"start\", dragstarted)\n          .on(\"drag\", dragged)\n          .on(\"end\", dragended));\n\n  node.append(\"title\")\n      .text(function(d) { return d.id; });\n\n  simulation\n      .nodes(graph.nodes)\n      .on(\"tick\", ticked);\n\n  simulation.force(\"link\")\n      .links(graph.links);\n\n  function ticked() {\n    link\n        .attr(\"x1\", function(d) { return d.source.x; })\n        .attr(\"y1\", function(d) { return d.source.y; })\n        .attr(\"x2\", function(d) { return d.target.x; })\n        .attr(\"y2\", function(d) { return d.target.y; });\n\n    node\n        .attr(\"cx\", function(d) { return d.x; })\n        .attr(\"cy\", function(d) { return d.y; });\n  }\n});\n\nfunction dragstarted(d) {\n  if (!d3.event.active) simulation.alphaTarget(0.3).restart();\n  d.fx = d.x;\n  d.fy = d.y;\n}\n\nfunction dragged(d) {\n  d.fx = d3.event.x;\n  d.fy = d3.event.y;\n}\n\nfunction dragended(d) {\n  if (!d3.event.active) simulation.alphaTarget(0);\n  d.fx = null;\n  d.fy = null;\n}");

  slide.code("Expandible Dendrite Plot", null, "var treeData =\n  {\n    \"name\": \"Top Level\",\n    \"children\": [\n      { \n        \"name\": \"Level 2: A\",\n        \"children\": [\n          { \"name\": \"Son of A\" },\n          { \"name\": \"Daughter of A\" }\n        ]\n      },\n      { \"name\": \"Level 2: B\" }\n    ]\n  };\n\n// Set the dimensions and margins of the diagram\nvar margin = {top: 20, right: 90, bottom: 30, left: 90},\n    width = 380 - margin.left - margin.right,\n    height = 666 - margin.top - margin.bottom;\n\n// append the svg object to the body of the page\n// appends a 'group' element to 'svg'\n// moves the 'group' element to the top left margin\nvar svg = d3.select(\"div.output\").append(\"svg\")\n    .attr(\"width\", width + margin.right + margin.left)\n    .attr(\"height\", height + margin.top + margin.bottom)\n  .append(\"g\")\n    .attr(\"transform\", \"translate(\"\n          + margin.left + \",\" + margin.top + \")\");\n\nvar i = 0,\n    duration = 750,\n    root;\n\n// declares a tree layout and assigns the size\nvar treemap = d3.tree().size([height, width]);\n\n// Assigns parent, children, height, depth\nroot = d3.hierarchy(treeData, function(d) { return d.children; });\nroot.x0 = height / 2;\nroot.y0 = 0;\n\n// Collapse after the second level\nroot.children.forEach(collapse);\n\nupdate(root);\n\n// Collapse the node and all it's children\nfunction collapse(d) {\n  if(d.children) {\n    d._children = d.children\n    d._children.forEach(collapse)\n    d.children = null\n  }\n}\n\nfunction update(source) {\n\n  // Assigns the x and y position for the nodes\n  var treeData = treemap(root);\n\n  // Compute the new tree layout.\n  var nodes = treeData.descendants(),\n      links = treeData.descendants().slice(1);\n\n  // Normalize for fixed-depth.\n  nodes.forEach(function(d){ d.y = d.depth * 180});\n\n  // ****************** Nodes section ***************************\n\n  // Update the nodes...\n  var node = svg.selectAll('g.node')\n      .data(nodes, function(d) {return d.id || (d.id = ++i); });\n\n  // Enter any new modes at the parent's previous position.\n  var nodeEnter = node.enter().append('g')\n      .attr('class', 'node')\n      .attr(\"transform\", function(d) {\n        return \"translate(\" + source.y0 + \",\" + source.x0 + \")\";\n    })\n    .on('click', click);\n\n  // Add Circle for the nodes\n  nodeEnter.append('circle')\n      .attr('class', 'node')\n      .attr('r', 1e-6)\n      .style(\"fill\", function(d) {\n          return d._children ? \"lightsteelblue\" : \"#fff\";\n      })\n      .attr(\"stroke\",\"#ccc\");\n\n  // Add labels for the nodes\n  nodeEnter.append('text')\n      .attr(\"dy\", \".35em\")\n      .attr(\"x\", function(d) {\n          return d.children || d._children ? -13 : 13;\n      })\n      .attr(\"text-anchor\", function(d) {\n          return d.children || d._children ? \"end\" : \"start\";\n      })\n      .text(function(d) { return d.data.name; });\n\n  // UPDATE\n  var nodeUpdate = nodeEnter.merge(node);\n\n  // Transition to the proper position for the node\n  nodeUpdate.transition()\n    .duration(duration)\n    .attr(\"transform\", function(d) { \n        return \"translate(\" + d.y + \",\" + d.x + \")\";\n     });\n\n  // Update the node attributes and style\n  nodeUpdate.select('circle.node')\n    .attr('r', 10)\n    .style(\"fill\", function(d) {\n        return d._children ? \"lightsteelblue\" : \"#fff\";\n    })\n    .attr('cursor', 'pointer');\n\n\n  // Remove any exiting nodes\n  var nodeExit = node.exit().transition()\n      .duration(duration)\n      .attr(\"transform\", function(d) {\n          return \"translate(\" + source.y + \",\" + source.x + \")\";\n      })\n      .remove();\n\n  // On exit reduce the node circles size to 0\n  nodeExit.select('circle')\n    .attr('r', 1e-6);\n\n  // On exit reduce the opacity of text labels\n  nodeExit.select('text')\n    .style('fill-opacity', 1e-6);\n\n  // ****************** links section ***************************\n\n  // Update the links...\n  var link = svg.selectAll('path.link')\n      .data(links, function(d) { return d.id; });\n\n  // Enter any new links at the parent's previous position.\n  var linkEnter = link.enter().insert('path', \"g\")\n      .attr(\"class\", \"link\")\n      .attr('d', function(d){\n        var o = {x: source.x0, y: source.y0}\n        return diagonal(o, o)\n      }).attr(\"stroke\",\"#ccc\") \n        .attr(\"stroke-width\",\"2px\")\n        .attr(\"fill\",\"None\")\n\n\n  // UPDATE\n  var linkUpdate = linkEnter.merge(link);\n\n  // Transition back to the parent element position\n  linkUpdate.transition()\n      .duration(duration)\n      .attr('d', function(d){ return diagonal(d, d.parent) });\n\n  // Remove any exiting links\n  var linkExit = link.exit().transition()\n      .duration(duration)\n      .attr('d', function(d) {\n        var o = {x: source.x, y: source.y}\n        return diagonal(o, o)\n      })\n      .remove();\n\n  // Store the old positions for transition.\n  nodes.forEach(function(d){\n    d.x0 = d.x;\n    d.y0 = d.y;\n  });\n\n  // Creates a curved (diagonal) path from parent to the child nodes\n  function diagonal(s, d) {\n\n    var path = `M ${s.y} ${s.x}\n            C ${(s.y + d.y) / 2} ${s.x},\n              ${(s.y + d.y) / 2} ${d.x},\n              ${d.y} ${d.x}`\n\n    return path\n  }\n\n  // Toggle children on click.\n  function click(d) {\n    if (d.children) {\n        d._children = d.children;\n        d.children = null;\n      } else {\n        d.children = d._children;\n        d._children = null;\n      }\n    update(d);\n  }\n}");

}).call(this);
